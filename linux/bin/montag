#!/usr/bin/env bash
# TODO: collect all options to one ffmpeg command, not more temp files
# TODO: use `ffmpeg -loglevel error` for quiet mode

set -e

print-help () {
    cat <<- EOF
‚îå‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ
‚îÇ-h‚îÇ --help      ‚îÇ Show this help message
‚îÇ-q‚îÇ --quiet     ‚îÇ See outputs of ffmpeg while processing
‚îÇ-i‚îÇ --input     ‚îÇ Input video, should have the same extension as [output-video]
‚îÇ-s‚îÇ --start     ‚îÇ Specifies the start point, e.g. 00:01:23.000 or 83 (in seconds)
‚îÇ-d‚îÇ --duration  ‚îÇ Duration, length, the same format as start (needs --start)
‚îÇ-t‚îÇ --to        ‚îÇ End point, the same format as start (needs --start)
‚îÇ-x‚îÇ --speed     ‚îÇ Speed of the output video (multiplier, e.g., 1.75)
‚îÇ  ‚îÇ --yes       ‚îÇ Work on the video immediately without the user's consent
‚îÇ  ‚îÇ --mute      ‚îÇ Mute audio
‚îÇ  ‚îÇ --crop      ‚îÇ Frame to crop the video, e.g. "in_w:in_h-40", see crop
‚îÇ  ‚îÇ             ‚îÇ   filter of ffmpeg: http://ffmpeg.org/ffmpeg-filters.html#crop
‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ
‚îÇ  ‚îÇ --gif       ‚îÇ Convert to gif, this will set these --fps to 10
‚îÇ  ‚îÇ --gif-loop  ‚îÇ How many loops your gif will do (default false)
‚îÇ  ‚îÇ --gif-delay ‚îÇ How long to delay the gif (default 10)
‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ
‚îÇ  ‚îÇ --width     ‚îÇ Width of the output (aspect ratio is preserved)
‚îÇ  ‚îÇ --fps       ‚îÇ Frames persecond
‚îú‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ
‚îÇ  ‚îÇ --ytdl      ‚îÇ yt-dlp additional args
‚îÇ  ‚îÇ --ydi       ‚îÇ yt-dlp interactive mode, requires whiptail
‚îî‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ‚îÑ

USAGE:
  montag -i <input-video> [options...] [-i <input-video> [options...]...] [output-video]

EXAMPLES:
  # get the first 10 seconds and speed up the video two times
  montag -i my-input-video.mp4 --duration 10 --speed 2

  # get the specified range of the video from "--start" to "--to" and speed up
  montag -i my-input-video.mp4 --start 00:10:21 --t 00:11:30 --speed 2
  montag -i my-input-video.mp4 -s 00:10:21 -t 00:11:30 -x 2 --ytdl "-u username -p password"
EOF
}

collect-arg-and-validate() {
    while (($#)); do
        arg=$1; shift
        case "$arg" in
            -q|--quiet) is_quiet=1 ;;
            -h|--help) is_help=1 ;;
            --yes) is_yes=1 ;;
            --mute) mute_audio=1 ;;
            --ytdi) is_ydi=1 ;;
            --ytdl) ytdl_options=("$1") && shift ;;
            --input|-i) input="$1"; shift ;;
            --start|-s) start_point="$1"; shift ;;
            --duration|-d) duration="$1"; shift ;;
            --to|-t) end_point="$1"; shift ;;
            --speed|-x) speed="$1"; shift ;;
            --crop) crop="$1"; shift ;;
            --width) width="$1"; shift ;;
            --fps) fps="$1"; shift ;;

            --gif) is_gif=1 ;;
            --gif-loop) gif_loop="$1"; shift ;;
            --gif-delay) gif_delay="$1"; shift ;;

            *)
                output="$arg"
                (($#)) && >&2 echo error: invalid number of arguments && exit 2
                ;;
        esac
    done

    ((is_help)) && print-help && exit 0

    # ----- IO -----

    prepare-input-and-output

    # ----- cutting -----

    if [ "$end_point" ] && [ "$duration" ]; then
        >&2 echo error\(cutting\): both end point and duration are provided
        exit 2
    fi

    if [ "$end_point" ] || [ "$duration" ]; then
        start_point=$([ "$start_point" ] && echo "$start_point" || echo "00:00:00")
    fi

    # ----- giffing -----

    if [ "$loop" ] && [ ! "$is_gif" ]; then
        >&2 echo error\(giffing\): can\'t use --loop without --gif
        exit 2
    fi
}

echo-debug() {
    [ "$is_quiet" ] || >&2 echo "=>" "$@"
}

get-file-name-from-url() {
    local output
    echo-debug Getting the file name from a url
    echo-debug yt-dlp "$(printf '"%s" ' "${ytdl_options[@]}")" --no-playlist -O \''%(title)s.%(ext)s'\' \'"$1"\'
    output="$(yt-dlp "${ytdl_options[@]}" --no-playlist -O '%(title)s.%(ext)s' "$1")"
    output="${output/\//\\\\}" # replace / with \\
        echo "$output"
}

prepare-input-and-output() {
    [ ! "$input" ] && echo error\(IO\): input file is required && exit 2

    if
    echo "$input" |
    grep -oP '^https?://' > /dev/null
    then
        # set video quality to <= 720p by default
        quality_settings="best[height<=720]"
        if [ "$is_ydi" ]; then
            echo-debug ydi -p \""$input"\"
            quality_settings="$(ydi -p "$input")"
        fi
        ytdl_options+=(-f "$quality_settings")

        if [ ! "$output" ]; then
            output=$(get-file-name-from-url "$input")
        fi
    elif [ ! "$output" ]; then
        # then same extension as the input
        output="$(echo "$input" | sed -e 's/^\(.*\)\.\(.*\)$/\1-montaged.\2/')"
    fi

    if [ "$is_gif" ]; then
        # use the same name with .gif as extension
        output="${output%.*}.gif"
    fi
}

get-input-args() {
    set -e # we have to do this again because this function is called as a command substitution
    local argv=("$@")
    local input="${argv[-1]}"
    unset 'argv[-1]'

    if echo "$input" | grep -oP '^https?://' > /dev/null; then
        # see: https://unix.stackexchange.com/questions/230481/how-to-download-portion-of-video-with-youtube-dl-command

        [ $is_quiet ] || >&2 echo-debug yt-dlp --no-playlist --youtube-skip-dash-manifest -g \""${ytdl_options[*]}"\"
        read -r -a links <<< "$(yt-dlp --no-playlist --youtube-skip-dash-manifest -g "${ytdl_options[@]}" "$input")"

        # put link inside 'single qutaion mark'
        if [ ${#links[@]} = 1 ]; then
            cmd+=("${argv[@]}" -i "${links[0]}")
        elif [ ${#links[@]} = 2 ]; then
            cmd+=("${argv[@]}" -i "${links[0]}" -i "${links[1]}" -map 0:v -map 1:a)
        else
            1>&2 echo 'ERROR: invalid output from "yt-dlp -g <url>"'
            [ ! "$is_quiet" ] &&
            1>&2 printf '==============\n%s\n' "${links[@]}"
            exit 1
        fi

        return 0
    fi

    cmd+=("$@")
}

# do-speedup() {
#     input_args="$(get-input-args "$1")"
#     cmd="ffmpeg $input_args -filter:v 'setpts=PTS/$speed' -filter:a 'atempo=$speed' '$2'"
#     echo-title "‚è©Ô∏è ... speedup the cut video x$speed"
# }

# do-convert-gif() {
#     local lfps=10 lloop=0 ldelay=10
#     [ -n "$fps"       ] && lfps=$fps
#     [ -n "$gif_loop"  ] && lloop=$gif_loop
#     [ -n "$gif_delay" ] && ldelay=$gif_delay
#     if [ "$width" ]; then local scale_filter=",scale=$width:-1:flags=lanczos"; fi
#     input_args="$(get-input-args "$1")"
#     # convert comes from `extra/imagemagick` Arch package
#     cmd="ffmpeg $input_args -vf 'fps=$lfps$scale_filter' -c:v pam -f image2pipe - |
#     convert -delay $ldelay - -loop $lloop -layers optimize '$2'"
#     echo-title "üèÉ ... generating a gif"
# }

print-cmd() {
    for arg in "$@"; do
        # add quotes if arg conatians a space
        if [[ "$arg" =~ " " ]]; then
            arg="\"$arg\""
        fi
        echo -n "$arg "
    done
}

get-user-acceptance() {
    [ "$is_yes" ] && return
    echo "üëá This is the final command"

    print-cmd "${cmd[@]}"
    if [[ ${#convert_cmd[@]} -gt 1 ]]; then
        echo " |"
        print-cmd "${convert_cmd[@]}"
    fi
    echo -n "\"$output\""
    echo
    echo

    read -r -p "continue ? ([Y]/n): " ans
    ans="$(echo "$ans" | tr '[:upper:]' '[:lower:]')"
    [ "$ans" = "y" ] || [ -z "$ans" ] || clear-and-exit 1
}

clear-and-exit() {
    # remove the temp file
    exit_code="${1:-0}"
    exit "$exit_code"
}

build-ffmpeg-command() {
    cmd=(ffmpeg)
    convert_cmd=(convert)

    # Quiet logs
    [ "$is_quiet" ] && cmd+=(-loglevel error)

    # Cut (Slice)
    if [ "$start_point" ]; then
        extra_description=$([ "$duration"  ] && echo "with length $duration" || echo "to $end_point")
        echo "‚úÇÔ∏è  ... cut part of the video from $start_point $extra_description"

        cut_args=(-ss "$start_point")
        [ "$duration"  ] && cut_args+=(-t "$duration")
        [ "$end_point" ] && cut_args+=(-to "$end_point")

        get-input-args "${cut_args[@]}" "$input"
    else
        get-input-args "$input"
    fi

    # Speed
    if [ "$speed" ]; then
        echo "‚è©Ô∏è  ... speedup the cut video x$speed"
        cmd+=(-filter:v "setpts=PTS/$speed" -filter:a "atempo=$speed")
    fi

    # Crop
    if [ "$crop" ]; then
        echo "üñºÔ∏è  ... crop the video with $crop"
        cmd+=(-vf "crop=$crop")
    fi

    # Mute audio
    if [ "$mute_audio" ]; then
        echo "üîá ... mute the audio"
        cmd+=(-an)
    fi

    # GIF conversion
    if [ "$is_gif" ]; then
        echo üìΩÔ∏è ... generating a gif
        fps=$((fps || 10))
        lloop=$((gif_loop || 0))
        ldelay=$((gif_delay || 10))
        cmd+=(-vf "fps=${fps}${width:+,scale=$width:-1:flags=lanczos}" -c:v pam -f image2pipe -)
        convert_cmd+=(-delay "$ldelay" - -loop "$lloop" -layers optimize)
    fi

    get-user-acceptance

    if [[ ${#convert_cmd[@]} -gt 1 ]]; then
        "${cmd[@]}" | "${convert_cmd[@]}" "$output" # run the final command
    else
        "${cmd[@]}" "$output"
    fi
}

collect-arg-and-validate "$@"
build-ffmpeg-command
clear-and-exit 0
